name: CI - sbt assembly & Docker build
#
on:
  push:
    branches:
      - main

jobs:
  terraform-validate:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Configure Azure credentials for Terraform
        id: azure-creds
        continue-on-error: true
        run: |
          # Essayer d'abord avec des secrets s√©par√©s (plus fiable)
          if [ -n "${{ secrets.ARM_CLIENT_ID }}" ] && \
             [ -n "${{ secrets.ARM_CLIENT_SECRET }}" ] && \
             [ -n "${{ secrets.ARM_SUBSCRIPTION_ID }}" ] && \
             [ -n "${{ secrets.ARM_TENANT_ID }}" ]; then
            echo "‚úÖ Using separate ARM_* secrets"
            echo "ARM_CLIENT_ID=${{ secrets.ARM_CLIENT_ID }}" >> $GITHUB_ENV
            echo "ARM_CLIENT_SECRET=${{ secrets.ARM_CLIENT_SECRET }}" >> $GITHUB_ENV
            echo "ARM_SUBSCRIPTION_ID=${{ secrets.ARM_SUBSCRIPTION_ID }}" >> $GITHUB_ENV
            echo "ARM_TENANT_ID=${{ secrets.ARM_TENANT_ID }}" >> $GITHUB_ENV
            echo "creds_configured=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Fallback : Parser le JSON des credentials
          if [ -z "${{ secrets.AZURE_CREDENTIALS }}" ]; then
            echo "creds_configured=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  AZURE_CREDENTIALS secret not set (and separate ARM_* secrets not found)"
            exit 0
          fi
          
          # Sauvegarder le JSON et valider qu'il est valide
          echo "${{ secrets.AZURE_CREDENTIALS }}" > /tmp/azure_creds.json
          
          # Afficher les premi√®res lignes pour debug (sans secrets sensibles)
          echo "üìã Checking JSON format..."
          head -3 /tmp/azure_creds.json | sed 's/".*": ".*"/"key": "***"/g' || true
          
          # Essayer de r√©parer le JSON si n√©cessaire (ajouter des guillemets manquants)
          # Si le JSON n'a pas de guillemets, on essaie de les ajouter
          if ! jq empty /tmp/azure_creds.json 2>/dev/null; then
            echo "‚ö†Ô∏è  JSON validation failed, trying to fix format..."
            # Essayer de r√©parer en ajoutant des guillemets si manquants
            cat /tmp/azure_creds.json | sed 's/{\([^"]*\):\([^,}]*\)/{"\1":"\2/g' | \
              sed 's/,\([^"]*\):\([^,}]*\)/,"\1":"\2/g' | \
              sed 's/\([^"]\)}/"\1}/g' > /tmp/azure_creds_fixed.json 2>/dev/null || true
            
            if jq empty /tmp/azure_creds_fixed.json 2>/dev/null; then
              echo "‚úÖ JSON fixed, using repaired version"
              mv /tmp/azure_creds_fixed.json /tmp/azure_creds.json
            else
              JSON_ERROR=$(jq empty /tmp/azure_creds.json 2>&1 || echo "ERROR")
              echo "‚ùå Invalid JSON in AZURE_CREDENTIALS secret"
              echo "   Error: $JSON_ERROR"
              echo "   First 200 chars: $(head -c 200 /tmp/azure_creds.json)"
              echo ""
              echo "üí° Tip 1: Use separate secrets: ARM_CLIENT_ID, ARM_CLIENT_SECRET, ARM_SUBSCRIPTION_ID, ARM_TENANT_ID"
              echo "üí° Tip 2: Copy the JSON from .github/AZURE_CREDENTIALS_ONE_LINE.txt"
              echo "creds_configured=false" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          
          # Extraire les valeurs
          ARM_CLIENT_ID=$(jq -r '.clientId' /tmp/azure_creds.json 2>/dev/null || echo "")
          ARM_CLIENT_SECRET=$(jq -r '.clientSecret' /tmp/azure_creds.json 2>/dev/null || echo "")
          ARM_SUBSCRIPTION_ID=$(jq -r '.subscriptionId' /tmp/azure_creds.json 2>/dev/null || echo "")
          ARM_TENANT_ID=$(jq -r '.tenantId' /tmp/azure_creds.json 2>/dev/null || echo "")
          
          # V√©rifier que toutes les valeurs sont pr√©sentes
          if [ -z "$ARM_CLIENT_ID" ] || [ -z "$ARM_CLIENT_SECRET" ] || \
             [ -z "$ARM_SUBSCRIPTION_ID" ] || [ -z "$ARM_TENANT_ID" ]; then
            echo "‚ùå Missing required fields in AZURE_CREDENTIALS"
            echo "creds_configured=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Configurer les variables d'environnement
          echo "ARM_CLIENT_ID=$ARM_CLIENT_ID" >> $GITHUB_ENV
          echo "ARM_CLIENT_SECRET=$ARM_CLIENT_SECRET" >> $GITHUB_ENV
          echo "ARM_SUBSCRIPTION_ID=$ARM_SUBSCRIPTION_ID" >> $GITHUB_ENV
          echo "ARM_TENANT_ID=$ARM_TENANT_ID" >> $GITHUB_ENV
          
          echo "creds_configured=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Azure credentials configured for Terraform (from JSON)"

      - name: Create backend config from secrets
        working-directory: infra
        continue-on-error: true
        run: |
          # Cr√©er backend-config.tfvars √† partir des secrets GitHub
          if [ -n "${{ secrets.TF_STATE_STORAGE_ACCOUNT }}" ]; then
            cat > backend-config.tfvars <<EOF
          resource_group_name  = "RG-SPARKLOL"
          storage_account_name = "${{ secrets.TF_STATE_STORAGE_ACCOUNT }}"
          container_name       = "tfstate"
          key                  = "prod.terraform.tfstate"
          EOF
            echo "backend_configured=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Backend config created from secrets"
          else
            echo "backend_configured=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  TF_STATE_STORAGE_ACCOUNT secret not set, skipping backend init"
          fi

      - name: Terraform Format Check
        working-directory: infra
        run: terraform fmt -check -recursive

      - name: Terraform Init (without backend)
        working-directory: infra
        run: terraform init -backend=false

      - name: Terraform Validate
        working-directory: infra
        run: terraform validate

      - name: Terraform Init (with backend)
        working-directory: infra
        continue-on-error: true
        run: |
          # V√©rifier que les secrets n√©cessaires sont pr√©sents
          CREDS_CONFIGURED="${{ steps.azure-creds.outputs.creds_configured }}"
          BACKEND_CONFIGURED="${{ steps.backend-config.outputs.backend_configured }}"
          
          if [ "$CREDS_CONFIGURED" != "true" ] || [ "$BACKEND_CONFIGURED" != "true" ]; then
            echo "‚ö†Ô∏è  Secrets not configured, skipping Terraform backend init"
            echo "   Creds configured: ${CREDS_CONFIGURED:-false}"
            echo "   Backend configured: ${BACKEND_CONFIGURED:-false}"
            exit 0
          fi
          
          terraform init \
            -backend-config=backend-config.tfvars \
            -input=false

      - name: Terraform Plan (Preview)
        working-directory: infra
        continue-on-error: true
        env:
          TF_VAR_sql_admin_password: ${{ secrets.SQL_ADMIN_PASSWORD }}
        run: |
          # V√©rifier que les secrets n√©cessaires sont pr√©sents
          CREDS_CONFIGURED="${{ steps.azure-creds.outputs.creds_configured }}"
          BACKEND_CONFIGURED="${{ steps.backend-config.outputs.backend_configured }}"
          SQL_PASSWORD="${{ secrets.SQL_ADMIN_PASSWORD }}"
          
          if [ "$CREDS_CONFIGURED" != "true" ] || \
             [ "$BACKEND_CONFIGURED" != "true" ] || \
             [ -z "$SQL_PASSWORD" ]; then
            echo "‚ö†Ô∏è  Secrets not configured, skipping Terraform plan"
            echo "   Creds configured: ${CREDS_CONFIGURED:-false}"
            echo "   Backend configured: ${BACKEND_CONFIGURED:-false}"
            echo "   SQL password: $([ -n "$SQL_PASSWORD" ] && echo "present" || echo "missing")"
            exit 0
          fi
          
          terraform plan \
            -var-file=envs/prod/terraform.tfvars \
            -out=tfplan \
            -no-color
          terraform show -no-color tfplan

      - name: Upload Plan Artifact
        if: always()
        uses: actions/upload-artifact@v4
        continue-on-error: true
        with:
          name: terraform-plan
          path: infra/tfplan
          retention-days: 1

  build-and-push:
    # üîë IMPORTANT : on ne pousse que sur push main (merge)
    if: github.event_name == 'push'
    runs-on: ubuntu-latest

    permissions:
      contents: read
      packages: write

    steps:
      # 1) Checkout
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2) sbt clean assembly (isol√©)
      - name: sbt clean assembly
        run: |
          docker run --rm \
            -v "$PWD:/app" \
            -w /app \
            sbtscala/scala-sbt:eclipse-temurin-17.0.4_1.7.1_3.2.0 \
            sbt clean assembly

      # 3) Docker build (compose)
      - name: Docker compose build
        run: docker compose build --no-cache

      # 4) Login GHCR
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # 5) Tag & push images (LOWERCASE STRICT)
      - name: Tag and push images to GHCR
        run: |
          set -e

          OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO=$(basename "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          TAG=main

          PRODUCER_IMAGE="ghcr.io/$OWNER/$REPO/producer"
          CONSUMER_IMAGE="ghcr.io/$OWNER/$REPO/consumer"

          echo "üì¶ Using images:"
          echo " - $PRODUCER_IMAGE:$TAG"
          echo " - $CONSUMER_IMAGE:$TAG"

          # üîç Debug images built
          docker images

          # Producer
          docker tag azuresparkkafka_clean-producer-players:latest $PRODUCER_IMAGE:$TAG
          docker tag azuresparkkafka_clean-producer-players:latest $PRODUCER_IMAGE:latest

          # Consumer
          docker tag azuresparkkafka_clean-spark-consumer-players:latest $CONSUMER_IMAGE:$TAG
          docker tag azuresparkkafka_clean-spark-consumer-players:latest $CONSUMER_IMAGE:latest

          # Push
          docker push $PRODUCER_IMAGE:$TAG
          docker push $PRODUCER_IMAGE:latest
          docker push $CONSUMER_IMAGE:$TAG
          docker push $CONSUMER_IMAGE:latest
          ls -lh target/scala-2.12

          echo "‚úÖ Images pushed successfully"
