name: CI - sbt assembly & Docker build
#
on:
  push:
    branches:
      - main

jobs:
  terraform-validate:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Configure Azure credentials for Terraform
        id: azure-creds
        continue-on-error: true
        run: |
          if [ -n "${{ secrets.ARM_CLIENT_ID }}" ] && \
             [ -n "${{ secrets.ARM_CLIENT_SECRET }}" ] && \
             [ -n "${{ secrets.ARM_SUBSCRIPTION_ID }}" ] && \
             [ -n "${{ secrets.ARM_TENANT_ID }}" ]; then
            echo "ARM_CLIENT_ID=${{ secrets.ARM_CLIENT_ID }}" >> $GITHUB_ENV
            echo "ARM_CLIENT_SECRET=${{ secrets.ARM_CLIENT_SECRET }}" >> $GITHUB_ENV
            echo "ARM_SUBSCRIPTION_ID=${{ secrets.ARM_SUBSCRIPTION_ID }}" >> $GITHUB_ENV
            echo "ARM_TENANT_ID=${{ secrets.ARM_TENANT_ID }}" >> $GITHUB_ENV
            echo "creds_configured=true" >> $GITHUB_OUTPUT
          else
            echo "creds_configured=false" >> $GITHUB_OUTPUT
          fi

      - name: Create backend config from secrets
        id: backend-config
        working-directory: infra
        continue-on-error: true
        run: |
          if [ -n "${{ secrets.TF_STATE_STORAGE_ACCOUNT }}" ]; then
            cat > backend-config.tfvars <<EOF
          resource_group_name  = "RG-SPARKLOL"
          storage_account_name = "${{ secrets.TF_STATE_STORAGE_ACCOUNT }}"
          container_name       = "tfstate"
          key                  = "prod.terraform.tfstate"
          EOF
            echo "backend_configured=true" >> $GITHUB_OUTPUT
          else
            echo "backend_configured=false" >> $GITHUB_OUTPUT
          fi

      - name: Terraform Format Check
        working-directory: infra
        run: terraform fmt -check -recursive

      - name: Terraform Init (without backend)
        working-directory: infra
        run: terraform init -backend=false

      - name: Terraform Validate
        working-directory: infra
        run: terraform validate

      - name: Terraform Init (with backend)
        working-directory: infra
        continue-on-error: true
        run: |
          if [ "${{ steps.azure-creds.outputs.creds_configured }}" != "true" ] || \
             [ "${{ steps.backend-config.outputs.backend_configured }}" != "true" ]; then
            exit 0
          fi
          terraform init -backend-config=backend-config.tfvars -input=false

      - name: Terraform Plan (Preview)
        working-directory: infra
        continue-on-error: true
        env:
          TF_VAR_sql_admin_password: ${{ secrets.SQL_ADMIN_PASSWORD }}
        run: |
          if [ "${{ steps.azure-creds.outputs.creds_configured }}" != "true" ] || \
             [ "${{ steps.backend-config.outputs.backend_configured }}" != "true" ] || \
             [ -z "${{ secrets.SQL_ADMIN_PASSWORD }}" ]; then
            exit 0
          fi
          terraform plan -var-file=envs/prod/terraform.tfvars -out=tfplan -no-color
          terraform show -no-color tfplan

      - name: Upload Plan Artifact
        if: always()
        uses: actions/upload-artifact@v4
        continue-on-error: true
        with:
          name: terraform-plan
          path: infra/tfplan
          retention-days: 1

  build-and-push:
    # üîë IMPORTANT : on ne pousse que sur push main (merge)
    if: github.event_name == 'push'
    runs-on: ubuntu-latest

    permissions:
      contents: read
      packages: write

    steps:
      # 1) Checkout
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2) sbt clean assembly (isol√©)
      - name: sbt clean assembly
        run: |
          docker run --rm \
            -v "$PWD:/app" \
            -w /app \
            sbtscala/scala-sbt:eclipse-temurin-17.0.4_1.7.1_3.2.0 \
            sbt clean assembly

      # 3) Docker build (compose)
      - name: Docker compose build
        run: docker compose build --no-cache

      # 4) Login GHCR
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # 5) Tag & push images (LOWERCASE STRICT)
      - name: Tag and push images to GHCR
        run: |
          set -e

          OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO=$(basename "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          TAG=main

          PRODUCER_IMAGE="ghcr.io/$OWNER/$REPO/producer"
          CONSUMER_IMAGE="ghcr.io/$OWNER/$REPO/consumer"

          # üîç Debug images built
          docker images

          # Producer
          docker tag azuresparkkafka_clean-producer-players:latest $PRODUCER_IMAGE:$TAG
          docker tag azuresparkkafka_clean-producer-players:latest $PRODUCER_IMAGE:latest

          # Consumer
          docker tag azuresparkkafka_clean-spark-consumer-players:latest $CONSUMER_IMAGE:$TAG
          docker tag azuresparkkafka_clean-spark-consumer-players:latest $CONSUMER_IMAGE:latest

          # Push
          docker push $PRODUCER_IMAGE:$TAG
          docker push $PRODUCER_IMAGE:latest
          docker push $CONSUMER_IMAGE:$TAG
          docker push $CONSUMER_IMAGE:latest
          ls -lh target/scala-2.12
